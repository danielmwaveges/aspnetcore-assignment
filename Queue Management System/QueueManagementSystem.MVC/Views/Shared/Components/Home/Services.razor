@using Microsoft.EntityFrameworkCore
@using QueueManagementSystem.MVC.Data
@using QueueManagementSystem.MVC.Models
@using QueueManagementSystem.MVC.Services
@using FastReport
@using FastReport.Export.PdfSimple;


@namespace QueueManagementSystem.MVC.Components

@*  In server-side Blazor apps, scoped service registrations can be problematic 
    because the instance is shared across components within the user's circuit.
    DbContext isn't thread safe and isn't designed for concurrent use.
    If there's any chance that multiple threads may access the same code block, 
    inject a factory and make a new instance per operation. *@
@inject IDbContextFactory<QueueManagementSystemContext> DbFactory
@inject ITicketService TicketService
@inject IReportService ReportService
@inject NavigationManager NavigationManager
@inject IJSRuntime JS

@if (offeredServices == null)
{
    <h4 class="display-4">Services Loading...</h4>
}
else
{
    <div class="row">
        @foreach (var service in offeredServices)
        {
            <div class="col-sm-6" style="overflow: auto;">
                <Card Color="CardColor.Light" TextAlignment="Alignment.Center" Class="mb-4">
                    <CardBody>
                        <CardTitle>@service.Name</CardTitle>
                        <CardText>@service.Description</CardText>
                        <div class="d-grid gap-2">
                            <Button Color="ButtonColor.Primary" Size="Size.ExtraLarge" Outline="true" @onclick="(() => HandleServiceSelection(service.Name))"> SELECT </Button>
                        </div>

                    </CardBody>
                </Card>
            </div>
        }
        
    </div>  
}

<script>
    downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    };
</script>

@code {
    private List<Service> offeredServices;

    private async Task PrintTicket(Ticket ticket)
    {
        Report report = ReportService.GenerateTicketReport(ticket);
        using (MemoryStream strm = new MemoryStream())
        {
            PDFSimpleExport pdfExport = new PDFSimpleExport();
            pdfExport.Export(report, strm);
            strm.Position = 0;
            var fileName = $"{ticket.TicketNumber}.pdf";

            using var streamRef = new DotNetStreamReference(strm);
            await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
        }
    }
    private async Task HandleServiceSelection(string serviceName)
    {
        //generate and add ticket to queue
        Ticket ticket = TicketService.GenerateTicket(serviceName);

        //print ticket
        await PrintTicket(ticket);
        
        //redirect to waiting page
        NavigationManager.NavigateTo("/Queue/WaitingPage", true);
    }
    
    protected override async Task OnInitializedAsync()
    {
        using var context = DbFactory.CreateDbContext();
        offeredServices = await context.Services.ToListAsync();
    }
}